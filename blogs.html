<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>BEST IN PAPER</title>

    <!-- Bootstrap Link -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx"
      crossorigin="anonymous"
    />

    <!-- CSS LINK -->
    <link rel="stylesheet" href="styles/style.css">

    <!-- Font Awesome Icon -->
    <script src="https://kit.fontawesome.com/1e93a2f115.js" crossorigin="anonymous"></script>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lobster&family=Poppins:wght@200;300;400;500;600;700&display=swap" rel="stylesheet">
  </head>
  <body>
    <header>
        <nav class="navbar bg-light">
          <div class="container">
            <a id="main" class="navbar-brand">Best In Paper</a>
            <div>
              <ul class="nav justify-content-end">
                <li class="nav-item">
                  <a class="nav-link active" aria-current="page" href="index.html"
                    >Home</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" aria-current="page" href="blogs.html">Blogs</a>
                </li>
              </ul>
            </div>
          </div>
        </nav>
        <!-- Second Navbar -->
        <div class="justify-content-between">
            <nav class="navbar navbar-expand-lg bg-light">
                <div class="container-fluid">
                  <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                  </button>
                  <div id="nav-container" class="container collapse navbar-collapse" id="navbarNav">
                    
                  </div>
                </div>
              </nav>
        </div>
    </header>

    <!-- main part -->
    <main>
        <section class="container">
            <div class="accordion" id="accordionExample">
                <div class="accordion-item">
                  <h2 class="accordion-header" id="headingOne">
                    <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="true" aria-controls="collapseOne">
                        Difference between var, let and const:
                    </button>
                  </h2>
                  <div id="collapseOne" class="accordion-collapse collapse show" aria-labelledby="headingOne" data-bs-parent="#accordionExample">
                    <div class="accordion-body">
                      <strong>Var:</strong> 
                      Before the advent of ES6, var declarations ruled. There are issues associated with variables declared with var, though. That is why it was necessary for new ways to declare variables to emerge. First, let's get to understand var more before we discuss those issues.<br>
                      <strong>Scope of var:</strong>
                      Scope essentially means where these variables are available for use. var declarations are globally scoped or function/locally scoped.<br>
                      
                      The scope is global when a var variable is declared outside a function. This means that any variable that is declared with var outside a function block is available for use in the whole window.<br>
                      
                      var is function scoped when it is declared within a function. This means that it is available and can be accessed only within that function.<br>
                      
                      <strong>var variables can be re-declared and updated:</strong>
                      This means that we can do this within the same scope and won't get an error.<br>
                      
                      <strong>Hoisting of var:</strong>
                      Hoisting is a JavaScript mechanism where variables and function declarations are moved to the top of their scope before code execution.<br>
                      
                      <strong>Let:</strong>
                      let is now preferred for variable declaration. It's no surprise as it comes as an improvement to var declarations. It also solves the problem with var that we just covered. Let's consider why this is so.<br>
                      
                      <strong>let is block scoped:</strong>
                      A block is a chunk of code bounded by {}. A block lives in curly braces. Anything within curly braces is a block.<br>
                      
                      <strong>let can be updated but not re-declared:</strong>
                      Just like var,  a variable declared with let can be updated within its scope. Unlike var, a let variable cannot be re-declared within its scope.<br>
                      
                      <strong>Hoisting of let:</strong>
                      Just like  var, let declarations are hoisted to the top. Unlike var which is initialized as undefined, the let keyword is not initialized. So if you try to use a let variable before declaration, you'll get a Reference Error.<br>
                      
                      <strong>Const:</strong>
                      Variables declared with the const maintain constant values. const declarations share some similarities with let declarations.<br>
                      
                      <strong>const declarations are block scoped:</strong>
                      Like let declarations, const declarations can only be accessed within the block they were declared.<br>
                      
                      <strong>const cannot be updated or re-declared:</strong>
                      This means that the value of a variable declared with const remains the same within its scope. It cannot be updated or re-declared.<br>
                      
                      <strong>Hoisting of const:</strong>
                      Just like let, const declarations are hoisted to the top but are not initialized.<br>
                      
                      <strong>Summary:</strong>
                      var declarations are globally scoped or function scoped while let and const are block scoped.
                      var variables can be updated and re-declared within its scope; let variables can be updated but not re-declared; const variables can neither be updated nor re-declared.
                      They are all hoisted to the top of their scope. But while var variables are initialized with undefined, let and const variables are not initialized.
                      While var and let can be declared without being initialized, const must be initialized during declaration.
                    </div>
                  </div>
                </div>
                <div class="accordion-item">
                  <h2 class="accordion-header" id="headingTwo">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo">
                        The Difference Between Regular Functions and Arrow Functions:
                    </button>
                  </h2>
                  <div id="collapseTwo" class="accordion-collapse collapse" aria-labelledby="headingTwo" data-bs-parent="#accordionExample">
                    <div class="accordion-body">
                      <strong>Arguments binding:</strong> 
                      Arrow functions do not have an arguments binding. However, they have access to the arguments object of the closest non-arrow parent function. Named and rest parameters are heavily relied upon to capture the arguments passed to arrow functions.<br>
                      
                      <strong>Use of this keyword:</strong>
                      Unlike regular functions, arrow functions do not have their own this. The value of this inside an arrow function remains the same throughout the lifecycle of the function and is always bound to the value of this in the closest non-arrow parent function.<br>
                      
                      <strong>Using new keyword:</strong>
                      Regular functions created using function declarations or expressions are constructible and callable. Since regular functions are constructible, they can be called using the new keyword.<br>
                      
                      However, the arrow functions are only callable and not constructible, i.e arrow functions can never be used as constructor functions. Hence, they can never be invoked with the new keyword.<br>
                      
                      <strong>No duplicate named parameters:</strong>
                      Arrow functions can never have duplicate named parameters, whether in strict or non-strict mode.
                    </div>
                  </div>
                </div>
                <div class="accordion-item">
                  <h2 class="accordion-header" id="headingThree">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseThree" aria-expanded="false" aria-controls="collapseThree">
                        Template Strings in JavaScript
                    </button>
                  </h2>
                  <div id="collapseThree" class="accordion-collapse collapse" aria-labelledby="headingThree" data-bs-parent="#accordionExample">
                    <div class="accordion-body">
                      <strong>Interpolating Variables and Expressions:</strong> 
                      We insert a variable or expression by adding a dollar sign $ and curly braces {} into the string `${variable}`.<br>
                      
                      As we can see it’s easy to make syntax errors with the old concatenation syntax if we have complex variables and expressions. Therefore template strings are a great improvement from what we had before.<br>
                      
                      If we want to use the backtick character in the content of string just put a \ before the backtick character in the string. => `will have a literal \` back tick`<br>
                      
                      <strong>Multiline Strings:</strong>
                      Another great feature of template strings is that we can have strings with multiple lines for better code readability. This cannot be done in an easy way with the old style of strings. With the old style of strings, we had to concatenate each line of the string to put long strings in multiple lines.<br>
                      As we can see, this will become really painful is we have many more lines. It’s very frustrating to have all those plus signs and divide the string into multiple lines.<br>
                      
                      This is much better than concatenating strings together. It takes a lot less time to write the code and a lower probability of syntax errors. It’s also much more readable.<br>
                      
                      Note that this method does add an actual new like to the string \n and if you don’t want the string to have multiple lines in its final format, just put a \ at the end of the line.<br>
                      
                      <strong>Nesting Templates:</strong>
                      Template strings can be nested in each other. This is a great feature because many people want to create dynamic strings. Template strings allow us to nest regular strings or template strings within template strings.<br>
                      
                      <strong>Tagged Templates:</strong>
                      With template strings, we can add something called tags in front of a template string. They are functions that take a string and the decomposed parts of the string as parameters. A tagged function decomposes the template string into an array as the first parameter, with each item of the array as the constant parts of the string. The additional parameters of the function are all the variables and expressions in the order in which they appear in the string.<br>
                      
                      Tagged templates are great for converting strings to anything you want since it’s just a regular function. However, it is a special function because the first parameter is an array containing the constant parts of the string. The rest of the parameters contain the returned values that each expression returns. This is great for manipulating the string and transforming the returned values to what we want.<br>
                      
                      The return value of tags can be anything you want. So we can return strings, arrays, objects, or anything else.<br>
                      
                      <strong>Raw Strings:</strong>
                      Template strings have a special raw property that you can get from tags. The raw property gets us the string without escaping the special characters, hence the property is called raw. To access the raw property of a string.
                    </div>
                  </div>
                </div>
              </div>
        </section>
    </main>

    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-A3rJD856KowSb7dwlZdYEkO39Gagi7vIsF0jrRAoQmDKKtQBHUuLZ9AsSv4jD4Xa"
      crossorigin="anonymous"
    ></script>
    <script src="js/app.js"></script>
  </body>
</html>
